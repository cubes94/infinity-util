/**
 * \        平均时间复杂度       最好情况        最坏情况     空间复杂度    排序方式    稳定性
 * 冒泡排序     O(n^2)            O(n)          O(n^2)        O(1)      In-place    稳定
 * {@link com.infinity.training.basis.algorithm.sort.BubbleSort}
 * 选择排序     O(n^2)            O(n^2)        O(n^2)        O(1)      In-place   不稳定
 * {@link com.infinity.training.basis.algorithm.sort.SelectionSort}
 * 插入排序     O(n^2)            O(n)          O(n^2)        O(1)      In-place    稳定
 * {@link com.infinity.training.basis.algorithm.sort.InsertSort}
 * 希尔排序     O(n log n)      O(n log^2 n)   O(n log^2 n)     O(1)      In-place   不稳定
 * {@link com.infinity.training.basis.algorithm.sort.ShellSort}
 * 归并排序     O(n log n)      O(n log n)     O(n log n)     O(n)      Out-place   稳定
 * {@link com.infinity.training.basis.algorithm.sort.MergeSort}
 * 快速排序     O(n log n)      O(n log n)      O(n^2)       O(log n)   In-place   不稳定
 * {@link com.infinity.training.basis.algorithm.sort.QuickSort}
 * 堆排序       O(n log n)      O(n log n)     O(n log n)     O(1)      In-place   不稳定
 * {@link com.infinity.training.basis.algorithm.sort.HeapSort}
 * 计数排序     O(n + k)         O(n + k)       O(n + k)      O(k)      Out-place   稳定
 * {@link com.infinity.training.basis.algorithm.sort.CountingSort}
 * 桶排序       O(n + k)         O(n + k)       O(n^2)      O(n + k)    Out-place   稳定
 * {@link com.infinity.training.basis.algorithm.sort.BucketSort}
 * 基数排序     O(n * k)         O(n * k)       O(n * k)    O(n + k)    Out-place   稳定
 * {@link com.infinity.training.basis.algorithm.sort.RadixSort}
 */
package com.infinity.training.basis.algorithm.sort;